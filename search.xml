<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F23%2Ftest%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[2019暑期慈溪中学三校学习集训体验]]></title>
    <url>%2F2019%2F08%2F18%2F2019%E6%9A%91%E6%9C%9F%E6%85%88%E6%BA%AA%E4%B8%AD%E5%AD%A6%E4%B8%89%E6%A0%A1%E5%AD%A6%E4%B9%A0%E9%9B%86%E8%AE%AD%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[被 吊 打 2019暑期慈溪中学三校学习集训体验​ 首先很高兴参与这次的集训，让我认识到了很多大佬，比如$bztminamoto$和衢州二中的$xyz$(二中之光)，$xzy$(徐致远指导$red sun$),$hl$(迷途知返闪总)。也在那边学习到了很多的，没有接触过的算法，虽然有些真的听不懂，但起码还是有所了解，也在$LYP$，$lwy$的帮助下了解了更多的$c++ stl$的容器和调试的技巧。 ​ 这次出行也让我(更加)了解到了我与那些大佬们的差距，也发现了做题量，算法学习量和代码编写上的差距，有一定的压力。虽然在集训间出现了诸如$NOIP取消$,$利奇马17级台风$之类的小插曲，但并不影响我想继续学习信息学竞赛的决心。也让我感到今后要更加努力，为下半年的提高初赛，复赛做准备。慈溪中学的学习环境十分的好，学校也是十分漂亮，$kblack$(计算几何，交互，平面几何，插头dp)讲师人也很好，但二中学长$LargestJN$和$gjghfd$的讲课(构造，网络流，数位dp)还是更容易听懂一点，可能是因为课题选择的不同。还有两位我也叫不出来名字的清华大佬(斜率dp，数论，数据结构)，讲的课也是很好，可惜我还是太菜，大概讲到一些$JSOI$或是$ZJOI$的总会掉线。在今后的学习中，我也会向他们看齐。在本次高强度的训练中，既有$OI$赛制，又有$ACM$赛制，一慢一快的比赛氛围也训练了我的心态，也使我对于题目的感受，理解更加深了。 ​ 总而言之本次集训令我印象深刻，具体水平的提升还要看下半年比赛的表现了。]]></content>
      <categories>
        <category>集训</category>
      </categories>
      <tags>
        <tag>-心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BSGS&exBSGS]]></title>
    <url>%2F2019%2F08%2F18%2FBSGS%20(Baby%20Steps%20Giant%20Steps)%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F%2F</url>
    <content type="text"><![CDATA[BSGS (Baby Steps Giant Steps)从入门到入土 BSGS (Baby Steps Giant Steps)从入门到入土1.BSGS求解如关于$x$的方程$A^x≡B \mod p$ 的最小整数解。$(A,p互质,p为质数)$ 不难发现$x&lt;=p$ 因为会出现循环。 靠虑将$x$分解为$i\times sqrt(x)-j$ 。 则原式化为$A^{i* \lceil sqrt(x)\rceil}\times A^{-j}≡B \mod p$ 对$A^{-j}$求逆元得$A^{i\times * \lceil sqrt(x)\rceil}≡B\times A^j \mod p$ 因为可以求一个同余方程$A^{-j}\times inv_{A^{-j}}≡1 mod p$ 显而易见$inv_{A^{-j}}$即为$A^j$ ,其实有点像移项，可惜$p$不与$A$互质移不过来，可能导致左边$mod p$后为$0$ 然后可知在$mod p$的意义下左右两式相等。 所以就可以用$map$吧左右的值映射成它的指数，先做右边($j$从$0$枚举到$\lceil sqrt(x)\rceil$),并把每次的$j$映射到$map$以$B\times A^j$为下标的空间中。然后做左边($i$从$1$枚举到$ \lceil sqrt(x)\rceil$)，每次查表搞一搞，第一次遇到相同的值就可以拿现在的$i\times \lceil sqrt(x)\rceil$与表中的$j$相减即为最小值，因为此时$i\times \lceil sqrt(x)\rceil$最小，$j$最大。 理论时间复杂度为$O(sqrt(p))$,但由于用了$map$所以多了红黑树查值的复杂度，所以多了个$log$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;long long b,p,a;void Read(long long &amp;x)&#123; long long f=1;x=0;char ch=getchar(); while (!isdigit(ch))&#123;if (ch=='-') f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+ch-'0';ch=getchar();&#125; x*=f;&#125;long long KSM(long long base,long long index,long long p)&#123; long long Res=1; while (index) &#123; if (index%2==1) Res*=base,Res%=p; base*=base; base%=p; index/=2; &#125; return Res%p;&#125;long long BSGS(long long a,long long b,long long p)&#123; map &lt;long long,long long&gt; m; long long X=(long long)ceil(sqrt(p)); m[b]=0; long long Ans_=b; for (int i=1;i&lt;=X;i++) Ans_*=a,Ans_%=p,m[Ans_]=i; long long Ans__=KSM(a,X,p); long long Ans___=1,Ans=-1; for (int i=1;i&lt;=X;i++) &#123; Ans___*=Ans__,Ans___%=p; if (m.count(Ans___)) &#123;Ans=i*X-m[Ans___];break;&#125; &#125; return Ans;&#125;int main() &#123; Read(p),Read(a),Read(b); long long answer=BSGS(a,b,p); if (answer==-1) cout&lt;&lt;"no solution"&lt;&lt;endl; else cout&lt;&lt;answer&lt;&lt;endl; return 0;&#125; 2.exBSGS若$A,p$不互质，那普通的$BSGS$就难以胜任了，所以需要使用$exBSGS$ 其实也很简单，假设$t=gcd(A,p)$,则可推出$A^{x-1}\times \frac{A}{t}≡\frac{B}{t} \mod p$ 若$t\nmid B$,则只有$B=1$时有$x=0$的最小解 若$t \mid b $,则当$t=1$时用$BSGS$,求解即可。 反复执行，直至$A,p$互质。 最后，若此过程需要反复进行$k$次,则答案为$BSGS$的解$x+k$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;long long b,p,a;void Read(long long &amp;x)&#123; long long f=1;x=0;char ch=getchar(); while (!isdigit(ch))&#123;if (ch=='-') f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+ch-'0';ch=getchar();&#125; x*=f;&#125;long long gcd(long long a,long long b)&#123; if (b==0) return a; return gcd(b,a%b);&#125;long long KSM(long long base,long long index,long long p)&#123; long long Res=1; while (index) &#123; if (index%2==1) Res*=base,Res%=p; base*=base; base%=p; index/=2; &#125; return Res%p;&#125;void ex_gcd(long long a,long long b,long long &amp;d,long long &amp;x,long long &amp;y) &#123; if (b==0) x=1,y=0,d=a; else &#123; ex_gcd(b,a%b,d,x,y); long long tmp=x;x=y;y=tmp-a/b*y; &#125;&#125;long long inv(long long a,long long b)&#123; long long x,y,d; ex_gcd(a,b,d,x,y); return (x%b+b)%b;&#125;long long BSGS(long long a,long long b,long long p)&#123; map &lt;long long,long long&gt; m; long long X=(long long)ceil(sqrt(p)); m[b]=0; long long Ans_=b; for (int i=1;i&lt;=X;i++) Ans_*=a,Ans_%=p,m[Ans_]=i; long long Ans__=KSM(a,X,p); long long Ans___=1,Ans=-1; for (int i=1;i&lt;=X;i++) &#123; Ans___*=Ans__,Ans___%=p; if (m.count(Ans___)) &#123;Ans=i*X-m[Ans___];break;&#125; &#125; return Ans;&#125;long long exBSGS(long long a,long long b,long long p)&#123; if (b==1||p==1)return 0; long long g=gcd(a,p),k=0,na=1; while (g!=1) &#123; if (b%g!=0)return -1; k++;b/=g;p/=g;na=na*(a/g)%p; if (na==b)return k; g=gcd(a,p); &#125; long long f=BSGS(a%p,b*inv(na,p)%p,p); if (f==-1)return -1; return f+k;&#125;int main() &#123; while (1) &#123; Read(a),Read(p),Read(b); if (p==0||a==0||b==0) break; long long answer=exBSGS(a,b,p); if (answer==-1) cout&lt;&lt;"No Solution"&lt;&lt;endl; else cout&lt;&lt;answer&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>-BSGS&amp;exBSGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟退火]]></title>
    <url>%2F2019%2F08%2F04%2F%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%2F</url>
    <content type="text"><![CDATA[模拟退火学习小结 关于模拟退火(以下来自百度百科) 模拟退火算法（Simulate Anneal，SA）是一种通用概率演算法，用来在一个大的搜寻空间内找寻命题的最优解。模拟退火是由S.Kirkpatrick, C.D.Gelatt和M.P.Vecchi在1983年所发明的。V.Čern&yacute;在1985年也独立发明此演算法。模拟退火算法是解决TSP问题的有效方法之一。 模拟退火的出发点是基于物理中固体物质的退火过程与一般组合优化问题之间的相似性。模拟退火算法是一种通用的优化算法，其物理退火过程由加温过程、等温过程、冷却过程这三部分组成。 所以要学OI先学好物理 模拟退火的具体流程先了解爬山算法吧！ 爬山算法就是对于一个函数随机选一个起始点，然后向着峰爬（最大or最小）。 但容易陷入局部最优解，如多峰函数。 而模拟退火则是用了一种较为科(玄)学的方法避免陷入局部最优解。 怎么做呢？ 就是对于一个较差的解，我们也有几率接受，假设此新解与最优解的差为$\Delta E$，此时温度为$T$,则概率为$e^{\frac{\Delta E}{kT}}$。($k$为一随机数，也可将$k$置为一常数)。 每次Rand这个$\Delta E$，一般为$(rand()\times 2-RANDMAX)\times Temperature$ $RANDMAX$为你这个种子的$Rand$最大值。这样方便$Rand$到正数和负数。 然后就判断是否接受后降温即可(一般取$0.9到0.99$之间,$Temperature*Down$) 当然，这是个玄学算法，需要有玄学的方法加强它的准确性。 以下推荐几种 分块退火(对每块退火后合并答案) 多退火几次 选多个起始位置 温度高点 降温系数慢点 种子选好点(比如某个八位质数$srand(time(0))$) 烧香祈福，提交前不要抽卡，洗把脸等等 例题平衡点/吊打XXX 均分数据 在此给出$平衡点/吊打XXX$的标程，$均分数据$由于最近没时间以后在更。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;#define Down 0.997#define MAXN 1005using namespace std;int N;double Ans_x=0,Ans_y=0,Ans_w;struct parm&#123;int x,y,w;&#125;Val[MAXN];struct node&#123; inline void Init(int &amp;x) &#123; int f=1;x=0;char ch=getchar(); while ('9'&lt;ch||ch&lt;'0') &#123;if (ch=='-') f=-1;ch=getchar();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-'0';ch=getchar();&#125; x*=f; &#125; inline void Outit(int x) &#123; if (x&lt;0) putchar('-'),x*=-1; if (x&gt;9) Outit(x/10); putchar(x%10+'0'); &#125;&#125;Put;struct Get_Ans&#123; double Get_Energy(double x,double y)//系统能量 &#123; double Sum=0; for (int i=1;i&lt;=N;i++) &#123; double dx=x-Val[i].x,dy=y-Val[i].y; Sum+=(double)sqrt(dx*dx+dy*dy)*Val[i].w; &#125; return Sum; &#125; void SA() &#123; double Tep=6000; while (Tep&gt;1e-15) &#123; double New_x=Ans_x+(rand()*2-RAND_MAX)*Tep; double New_y=Ans_y+(rand()*2-RAND_MAX)*Tep; double New_w=Get_Energy(New_x,New_y); double Delta=New_w-Ans_w; if (Delta&lt;0) Ans_x=New_x,Ans_y=New_y,Ans_w=New_w; else if (exp(-Delta/Tep)*RAND_MAX&gt;rand()) Ans_x=New_x,Ans_y=New_y; Tep*=Down; &#125; &#125;&#125;T;int main()&#123; srand(time(0));srand(rand());srand(rand());srand(rand());srand(rand());srand(rand());srand(rand()); Put.Init(N); for (int i=1;i&lt;=N;i++) Put.Init(Val[i].x),Put.Init(Val[i].y),Put.Init(Val[i].w),Ans_x+=Val[i].x,Ans_y+=Val[i].y; //for (int i=1;i&lt;=N;i++) cout&lt;&lt;Val[i].x&lt;&lt;" "&lt;&lt;Val[i].y&lt;&lt;" "&lt;&lt;Val[i].w&lt;&lt;endl; Ans_x=(double)Ans_x/N;Ans_y=(double)Ans_y/N; Ans_w=T.Get_Energy(Ans_x,Ans_y); T.SA(); T.SA(); T.SA(); T.SA(); T.SA(); printf("%.3lf %.3lf\n",Ans_x,Ans_y); return 0;&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>-模拟退火</tag>
      </tags>
  </entry>
</search>
