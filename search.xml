<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BZOJ刷题单及一句话心得题解]]></title>
    <url>%2F2019%2F12%2F07%2FBZOJ%E5%88%B7%E9%A2%98%E5%8D%95%E5%8F%8A%E4%B8%80%E5%8F%A5%E8%AF%9D%E5%BF%83%E5%BE%97%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[爆 炸 O J 数 据 结 构 题树树链剖分luogu P3313 [SDOI2014]旅行这个真没什么好讲的了，套路题，就是开多颗线段树维护不同教的信息，然后动态开点减少空间即可AC。点此康代码 LCAluogu P2680 运输计划一道思维题，本来以为是树剖(确实可以)，但实现麻烦，于是就二分答案然后树上差分判断，首先我们舍弃掉时间小于二分值的，因为它不用虫洞也不会对答案造成影响，然后对于剩下的找一个最长的且被剩下任务全包含的道路开虫洞，如果最长的任务行那就行了，否则就不行了，代码好写易懂，但是卡常恶心，必须要$tarjan$求$LCA$，把$log$变为$1$才可以通过。点此康代码 主席树luogu P3302[SDOI2013]森林比较恶心，一开始还以为是$LCT$的题，但一看到第$k$小就想到了主席树，可以用启发式合并优化合并操作到$logn$，然后查询可以用树上点差分的方式优化到$logn$，但$LCA$细节十分恶心，比如不能用普通的倍增范围，因为有合并操作，然后还要一开始判断一下$x==y$，被卡了好久，维护的东西也较多。点此康代码 luogu P3168 [CQOI2015]任务查询系统这个就比较简单了，相较于$P3302[SDOI2013]森林$，离散化优先级$p$后直接差分开搞，比较套路题，就是获取$k$过程中要开LL。点此康代码 线段树线段树合并bzoj P4399 魔法少女LJJ 一看十分不可做的题，断点断边维护还以为要$LCT$，但是数据$c&lt;=7$,还开了$20s$,所以线段树合并轻松水过，但是此题的合并姿势十分奇特，用一般的方法会$WA$，比如manchery学长的此题，具体原因我也不是特别清楚，甚至还因为这个卡了一个礼拜……，然后还有一大坑点是询问连通块权值之积，会爆$LL$，要用小数对数来存就可以了，涨姿势了。点此康代码 数 学 题算 法 题乱 搞 题带 模 拟 题]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>-BZOJ -题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF242E XOR on Segment]]></title>
    <url>%2F2019%2F10%2F05%2FCF242E-XOR-on-Segment%2F</url>
    <content type="text"><![CDATA[分 块 大 法 好 题面给定一个长为$n$($n&lt;=10^5$)的数组 数组里的数不超过$10^6$ 有两种操作： 1:求sum$[l,r]$; 2:对$[l,r]$中的所有数和$x$异或 操作数$m&lt;=5*10^4$ 思路挺好的一道题。 首先看到这题想到用一个数据结构来维护。 那是什么呢？线段树？分块？ 都可以。 但考虑到一个问题——区间异或没有逆分配律。 那怎么办。显然一般的线段树与分块达不到我们的要求。 考虑把每一个数拆开，因为数组里的数不超过$10^6$，所以只需要拆$20$位就可以满足需要。 然后大力分块，每块维护当前这块数$1到20位$的$1$的个数与本块当前的标记$0或是1$。答案就是$[l,r]$中$[1,20]$位分别乘上$2的[1,20]$次方。 代码写得自认为很清楚了。 自己康康吧。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define LL intusing namespace std;struct block&#123;int sum[25],tag[25],l,r;&#125;B[100005];int N,Q,a[100005],len,tot,num[100005],p[25];inline void Read(int &amp;x)&#123; int f=1;x=0;char ch=getchar(); while (!isdigit(ch))&#123;if (ch=='-') f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+ch-'0';ch=getchar();&#125; x*=f;&#125;inline void Xor(int l,int r,int x,int id)&#123; if (x==0) return;//如果是0就不用管了 if (num[l]==num[r])&#123;for (int i=l;i&lt;=r;i++) if (a[i]&gt;&gt;id&amp;1) B[num[i]].sum[id]--,a[i]^=(1&lt;&lt;id);else B[num[i]].sum[id]++,a[i]^=(1&lt;&lt;id); &#125; else &#123; for (int i=l;i&lt;=B[num[l]].r;i++) if (a[i]&gt;&gt;id&amp;1) B[num[i]].sum[id]--,a[i]^=(1&lt;&lt;id);else B[num[i]].sum[id]++,a[i]^=(1&lt;&lt;id); for (int i=num[l]+1;i&lt;=num[r]-1;i++) B[i].tag[id]^=1; for (int i=B[num[r]].l;i&lt;=r;i++) if (a[i]&gt;&gt;id&amp;1) B[num[i]].sum[id]--,a[i]^=(1&lt;&lt;id);else B[num[i]].sum[id]++,a[i]^=(1&lt;&lt;id); &#125;&#125;inline int ask(int l,int r,int id)&#123; int res=0; if (num[l]==num[r])&#123;for (int i=l;i&lt;=r;i++) if (B[num[i]].tag[id]^((a[i]&gt;&gt;id)&amp;1)) res++;&#125; else &#123; for (int i=l;i&lt;=B[num[l]].r;i++) if (B[num[i]].tag[id]^((a[i]&gt;&gt;id)&amp;1)) res++; for (int i=num[l]+1;i&lt;=num[r]-1;i++) if (B[i].tag[id]==1) res+=len-B[i].sum[id];else res+=B[i].sum[id];//如果块的id位上标记为1，则1变0,0变1 for (int i=B[num[r]].l;i&lt;=r;i++) if (B[num[i]].tag[id]^((a[i]&gt;&gt;id)&amp;1)) res++; &#125; return res;&#125;int main()&#123; p[0]=1; for (int i=1;i&lt;=20;i++) p[i]=p[i-1]*2; Read(N); for (int i=1;i&lt;=N;i++) Read(a[i]); Read(Q); len=sqrt(N); tot=N/len; if (N%len) tot++; for (int i=1;i&lt;=tot;i++) B[i].l=len*(i-1)+1,B[i].r=len*i; B[tot].r=N; for (int i=1;i&lt;=N;i++) num[i]=(i-1)/len+1; for (int id=0;id&lt;=20;id++)&#123;for (int i=1;i&lt;=N;i++) B[num[i]].sum[id]+=((a[i]&gt;&gt;id)&amp;1);&#125; while (Q--) &#123; int opt,l,r,x; Read(opt); if (opt==1) &#123; Read(l),Read(r); long long ans=0; for (int id=0;id&lt;=20;id++) ans+=1LL*ask(l,r,id)*p[id]; cout&lt;&lt;ans&lt;&lt;endl; &#125; else &#123; Read(l),Read(r),Read(x); for (int id=0;id&lt;=20;id++) Xor(l,r,x&gt;&gt;id&amp;1,id); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>-分块 -位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9.15比赛]]></title>
    <url>%2F2019%2F09%2F15%2F9.15%E6%AF%94%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[反 向 登 顶 9.15比赛T1Description传说，数千年前圣帕特里克消灭了哞尔兰所有的蛇。然而，蛇们现在卷土重来了！圣帕特里克 节是在每年的$ 3 月 17 日$，所以 $Bessie$ 要用彻底清除哞尔兰所有的蛇来纪念圣帕特里克。$ Bessie$ 装备了一个捕网，用来捕捉 $N $组排成一行的蛇$（1≤N≤400）$。 $Bessie$ 必须按照这些组在 这一行中出现的顺序捕捉每一组的所有蛇。每当 $Bessie$ 抓完一组蛇之后，她就会将蛇放在笼子里， 然后带着空的捕网开始捕捉下一组。 一个大小为 $s $的捕网意味着$ Bessie$ 可以抓住任意包含 $g$ 条的一组蛇，其中 $g≤s$。然而，每当 $Bessie $用大小为 $s$ 的捕网抓住了一组$ g $条蛇，就意味着浪费了$ s−g $的空间。$Bessie$ 可以任意设定捕网的初始大小，并且她可以改变$ K $次捕网大小$（1≤K&lt;N）$。 请告诉 $Bessie$ 她捕捉完所有组的蛇之后可以达到的总浪费空间的最小值。 Input输入的第一行包含 $N$ 和 $K$。第二行包含 N 个整数 $a1,…,aN$，其中 $ai$$（0≤ai≤10^6）$为第$ i $组蛇 的数量。 Output输出一个整数，为 Bessie 抓住所有蛇的总浪费空间的最小值。 思路1.方程是$F[i][j]$表示捕蛇到$i$组用了$j$次改变机会。 2.每次改变一定是取区间内最多蛇的个数的，这一点是个人都想得到。 3.思路很明确了，一个分割区间$DP$+预处理也好数据结构也好大力维护区间最值。 然后千万不要像我一样$sb$地把$int$初始化为$127$,会爆的，用$63$就好了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;int n,maxf[405][25],a[405],K,f[405][405],Sum[405];void rmq_max()&#123; for(int i=1;i&lt;=n;i++) maxf[i][0]=a[i]; for(int j=1;(1&lt;&lt;j)&lt;=n;j++) for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) maxf[i][j]=max(maxf[i][j-1],maxf[i+(1&lt;&lt;(j-1))][j-1]);&#125; int answer_max(int l,int r)&#123; int k=trunc(log2(r-l+1)); return max(maxf[l][k],maxf[r-(1&lt;&lt;k)+1][k]);&#125;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while (ch&lt;'0'||ch&gt;'9') &#123;if (ch=='-') f=-f;ch=getchar();&#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') ret=ret*10+ch-'0',ch=getchar(); return ret*f;&#125;int main()&#123; freopen("pa.in","r",stdin); freopen("pa.out","w",stdout); n=read();K=read();K++; for(int i=1;i&lt;=n;i++) a[i]=read(),Sum[i]=Sum[i-1]+a[i]; rmq_max(); memset(f,63,sizeof(f)); f[0][0]=0; for (int i=1;i&lt;=n;i++) &#123; for (int j=0;j&lt;=i-1;j++) &#123; for (int k=1;k&lt;=K;k++) &#123; f[i][k]=min(f[i][k],f[j][k-1]+answer_max(j+1,i)*(i-j)-(Sum[i]-Sum[j])); &#125; &#125; &#125; int Min=2e9; for (int i=1;i&lt;=K;i++) Min=min(Min,f[n][i]); cout&lt;&lt;Min&lt;&lt;endl; return 0;&#125; SourceUSACO 2019 US Open Contest, Gold Problem 1. Snakes T2Description$Farmer John$ 想要将他的编号为 $1…N$ 的 $N$ 头奶牛$（N≤7500）$分为非空的 $K$ 组$（2≤K≤N）$，使 得任意两头来自不同组的奶牛都需要走一定的距离才能相遇。奶牛 $x$ 和奶牛$ y$$（其中 1≤x&lt;y≤N）$ 愿意为了见面走$(2019201913x+2019201949y) \mod 2019201997 $英里。 给定一个将$ N $头奶牛分为$ K $个非空小组的分组方案，令$ M $为任意两头来自不同组的奶牛愿意 为了见面行走的英里数的最小值。为了测试奶牛们相互之间的忠诚度，$Farmer John $想要将 $N $头奶 牛以最佳的方式分为$ K$ 组，使得 $M$ 尽可能大。 Input 输入仅有一行，包含 $N$ 和 $K$，用空格分隔。 Output输出最优的 $M$。 思路考场里想法是把所有的路全挑出来，然后从小到大排序，二分断点$x$，前面$n-x$条放一组$(很显然)$,后面只要点不在前面集合内就$cnt++$,$cnt&gt;=k$就返回$1$,否则返回$0$。 然而$sort$超时了$(噔噔咚)$,$TLE 58pts$。 考完后看了题解才发现，只要把前$n-k$条放一组,后$k$条放一组就是最优的了$(好显然啊，哭了)$。 所以$TLE$代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define Maxn 7505 using namespace std;struct edge&#123;int a,b;long long c;&#125;e[Maxn*Maxn];bool vis[Maxn*Maxn];int N,K,cnt=0;bool cmp(edge x,edge y)&#123;return x.c&lt;y.c;&#125;bool check(int x)&#123; int ans=0; if (x&gt;1) ans++; memset(vis,0,sizeof(vis)); for (int i=1;i&lt;=x-1;i++) vis[e[i].a]=1,vis[e[i].b]=1; for (int i=x;i&lt;=cnt;i++) &#123; if (!vis[e[i].a]) ans++,vis[e[i].a]=1; if (!vis[e[i].b]) ans++,vis[e[i].b]=1; &#125; if (ans&gt;=K) return 1; return 0;&#125;int main()&#123; freopen("pb.in","r",stdin); freopen("pb.out","w",stdout); scanf("%d%d",&amp;N,&amp;K); for (int i=1;i&lt;=N-1;i++) &#123; for (int j=i+1;j&lt;=N;j++) &#123; long long x=(1LL*2019201913*i+1LL*2019201949*j)%2019201997; e[++cnt].a=i,e[cnt].b=j,e[cnt].c=x; &#125; &#125; sort(e+1,e+cnt+1,cmp); //for (int i=1;i&lt;=cnt;i++) cout&lt;&lt;e[i].c&lt;&lt;endl; int l=1,r=cnt; while (l&lt;=r) &#123; int mid=l+r&gt;&gt;1; if (check(mid)) l=mid+1; else r=mid-1; &#125; cout&lt;&lt;e[r].c&lt;&lt;endl; return 0;&#125; 满分代码如下 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;#define LL long longusing namespace std;const LL p1=2019201913,p2=2019201949,TT=2019201997;int n,k;LL f[7505];int main()&#123; freopen("pb.in","r",stdin); freopen("pb.out","w",stdout); scanf("%d%d",&amp;n,&amp;k); for (int i=1;i&lt;=n;i++) f[i]=TT; for (int i=1;i&lt;=n;i++) for (int j=i+1;j&lt;=n;j++)&#123; LL sum=(p1*i+p2*j)%TT; f[i]=min(f[i],sum); f[j]=min(f[j],sum); &#125; sort(f+1,f+n+1); printf("%lld\n",f[n-(k-2)]); return 0;&#125; 然后你甚至可以打表找规律，$O(1)$出奇迹！$LYP$%%% 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;inline int read()&#123; int red=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123; if(ch=='-') f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') red=red*10+ch-48,ch=getchar(); return red*f;&#125;typedef long long LL;const int maxn=7505;const LL mod=2019201997,first=2019201769;int n,m,k;LL f[maxn][maxn];int main()&#123; freopen("pb.in","r",stdin); freopen("pb.out","w",stdout); n=read()-3,m=read()-2; printf("%lld\n",(first-n*48-m*84+mod)%mod);// printf("%lld\n",f[n][m]); return 0;&#125;//LYPjulao%%% Source USACO 2019 US Open Contest, Gold Problem 2. I Would Walk 500 Miles T3Description Bessie 喜欢观光，而今天她正在寻找景色优美的山谷。 她感兴趣的是一个 N×N 的方阵，其中每个格子都有一个高度。所有在此正方形方阵之外的格 子的高度可以被看作是无限大。 山谷指的是一块连续、不含洞的一块区域，并且每个相邻的包围该区域的格子都高于这块区域 中的所有格子。 更形式化地说： 一组格子被称作是“沿边相邻的”，如果可以从其中任意一个格子出发，经过一些沿上、下、左、 右方向的移动，到达其中所有其他格子。 一组格子被称作是“沿点相邻的”，如果可以从其中任意一个格子出发，经过一些沿上、下、左、 右、对角线方向的移动，到达其中所有其他格子。 一个“区域”指的是一组非空并且沿边相邻的格子。 一个区域被称作是“有洞的”，如果这个区域的补集（包括在 $N \times N$ 方阵之外的无限 高格子）不是沿点相邻的。 区域的“边界”指的是所有与该区域内的某个格子正交相邻（上、下、左、右），但本身不在该区 域内的格子。 一个“山谷”指的是某个非有洞区域，满足区域内的任意格子的高度低于该区域边界上任意格子 的高度。 Bessie 的目标是求出所有山谷的大小之和。一些例子 这是一个区域： oo. ooo ..o 这不是一个区域（中间的格子和右下角的格子不沿边相邻）： oo. oo. ..o 这是一个非有洞区域： ooo o.. o.. 这是一个有洞的区域（“甜甜圈”中间的格子与区域外的格子不沿点相邻）： ooo o.o ooo 这是另一个非有洞区域（中间的格子与右下角的格子沿点相邻）： ooo o.o oo. Input输入的第一行包含 $N$，其中 $1≤N≤750$ 。 以下 $N$ 行每行包含 $N$ 个整数，为方阵每个格子的高度。所有高度 h 满足 $1≤h≤10^6$。所有 高度均为不同的整数。 Output输出一个整数，为所有山谷的大小之和 思路打不来，黑题，告辞。 要看的可以去这里看。]]></content>
      <categories>
        <category>常规训练</category>
      </categories>
      <tags>
        <tag>-比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[白金元首与克劳德斯]]></title>
    <url>%2F2019%2F08%2F21%2F%E7%99%BD%E9%87%91%E5%85%83%E9%A6%96%E4%B8%8E%E5%85%8B%E5%8A%B3%E5%BE%B7%E6%96%AF%2F</url>
    <content type="text"><![CDATA[科 学 题 题面思路本题偏向思维吧，需要注意一点，开始时所有云都是没有重叠面积且速度相同的，所以往同一方向的云都是相对静止的，并且云的速度方向只有向右和向上，这样就给了我们一个十分优秀的性质—只有向上与向右的云才会重叠，并且最多一个位置只能被两朵云覆盖，最少一朵云，所以只需要判断任意一朵的向右的云是否将会与向上的相交即可，设向右的云有$n$朵，向上的云有$m$朵，那么$n*m$的做法已经不难想出了，但明显是无法拿满分的，需要优化。这时我们或许会想起初中科学老师的教导相对运动这一概念，我们把向上的云固定住，向右的云就变成了向右下$45度$角运动，这样它的右上角和左下角会与$x$轴有交点，然后我们对于一种方向的云他的右上角和左下角的连线映射到$x$轴上，然后对另一种方向的云判断是否有一条线段会与它重叠即可，可以用差分，线段树，排序，二分做。在这里我用的是标记永久化线段树。 细节因为边缘不算，所以要对一种运动的矩形的对角线在$x$轴上左开右开，对另一种运动的矩形的对角线的查询要左闭右闭，然后离散化。 代码个人觉得这篇题解写得不大好，还望各位通过代码理解。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// luogu-judger-enable-o2#include&lt;bits/stdc++.h&gt;using namespace std;struct node&#123;int l,r,opt;&#125;seg[100005];int tmp[200005],top=0,T,n;void Read(int &amp;x)&#123; int f=1;x=0;char ch=getchar(); while (!isdigit(ch))&#123;if (ch=='-') f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+ch-'0';ch=getchar();&#125; x*=f;&#125;struct Tree&#123; int tree[800005],mark[800005]; void add(int rt,int l,int r,int ql,int qr) &#123; if (l&gt;=ql&amp;&amp;r&lt;=qr) &#123;mark[rt]+=1;return;&#125; tree[rt]+=min(qr,r)-max(ql,l)+1; int mid=l+r&gt;&gt;1; if (ql&lt;=mid) add(rt&lt;&lt;1,l,mid,ql,qr); if (qr&gt;mid) add(rt&lt;&lt;1|1,mid+1,r,ql,qr); &#125; int ask(int rt,int l,int r,int ql,int qr) &#123; if (l&gt;qr||r&lt;ql) return 0; if(l&gt;=ql&amp;&amp;r&lt;=qr) return tree[rt]+(r-l+1)*mark[rt]; int mid=l+r&gt;&gt;1; int res=(min(qr,r)-max(ql,l)+1)*mark[rt]; if (ql&lt;=mid) res+=ask(rt&lt;&lt;1,l,mid,ql,qr); if (qr&gt;mid) res+=ask(rt&lt;&lt;1|1,mid+1,r,ql,qr); return res; &#125;&#125;S;int main()&#123; Read(T); while(T--) &#123; top=0; memset(seg,0,sizeof(seg)); memset(tmp,0,sizeof(tmp)); memset(S.tree,0,sizeof(S.tree)); memset(S.mark,0,sizeof(S.mark)); Read(n); for (int i=1;i&lt;=n;i++) &#123; int x,y,w,h,d; Read(x),Read(y),Read(w),Read(h),Read(d); if (d==1) seg[i].l=x+y+1,seg[i].r=x+y+w+h-1; if (d==0) seg[i].l=x+y,seg[i].r=x+y+w+h; seg[i].opt=d; if (d==1) tmp[++top]=x+y+1,tmp[++top]=x+y+w+h-1; if (d==0) tmp[++top]=x+y,tmp[++top]=x+y+w+h; &#125; sort(tmp+1,tmp+top+1); int cnt=unique(tmp+1,tmp+top+1)-tmp-1; for (int i=1;i&lt;=n;i++) &#123; seg[i].l=lower_bound(tmp+1,tmp+cnt+1,seg[i].l)-tmp; seg[i].r=lower_bound(tmp+1,tmp+cnt+1,seg[i].r)-tmp; if (seg[i].opt==0) S.add(1,1,cnt,seg[i].l,seg[i].r); &#125; bool flag=0; for (int i=1;i&lt;=n;i++) if (seg[i].opt==1) if (S.ask(1,1,cnt,seg[i].l,seg[i].r)&gt;0) &#123; cout&lt;&lt;2&lt;&lt;endl; flag=1; break; &#125; if (!flag) cout&lt;&lt;1&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>-线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019暑期慈溪中学三校学习集训体验]]></title>
    <url>%2F2019%2F08%2F18%2F2019%E6%9A%91%E6%9C%9F%E6%85%88%E6%BA%AA%E4%B8%AD%E5%AD%A6%E4%B8%89%E6%A0%A1%E5%AD%A6%E4%B9%A0%E9%9B%86%E8%AE%AD%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[被 吊 打 2019暑期慈溪中学三校学习集训体验​ 首先很高兴参与这次的集训，让我认识到了很多大佬，比如$bztminamoto$和衢州二中的$xyz$(二中之光)，$xzy$(徐致远指导$red sun$),$hl$(迷途知返闪总)。也在那边学习到了很多的，没有接触过的算法，虽然有些真的听不懂，但起码还是有所了解，也在$LYP$，$lwy$的帮助下了解了更多的$c++ stl$的容器和调试的技巧。 ​ 这次出行也让我(更加)了解到了我与那些大佬们的差距，也发现了做题量，算法学习量和代码编写上的差距，有一定的压力。虽然在集训间出现了诸如$NOIP取消$,$利奇马17级台风$之类的小插曲，但并不影响我想继续学习信息学竞赛的决心。也让我感到今后要更加努力，为下半年的提高初赛，复赛做准备。慈溪中学的学习环境十分的好，学校也是十分漂亮，$kblack$(计算几何，交互，平面几何，插头dp)讲师人也很好，但二中学长$LargestJN$和$gjghfd$的讲课(构造，网络流，数位dp)还是更容易听懂一点，可能是因为课题选择的不同。还有两位我也叫不出来名字的清华大佬(斜率dp，数论，数据结构)，讲的课也是很好，可惜我还是太菜，大概讲到一些$JSOI$或是$ZJOI$的总会掉线。在今后的学习中，我也会向他们看齐。在本次高强度的训练中，既有$OI$赛制，又有$ACM$赛制，一慢一快的比赛氛围也训练了我的心态，也使我对于题目的感受，理解更加深了。 ​ 总而言之本次集训令我印象深刻，具体水平的提升还要看下半年比赛的表现了。]]></content>
      <categories>
        <category>集训</category>
      </categories>
      <tags>
        <tag>-心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BSGS&exBSGS]]></title>
    <url>%2F2019%2F08%2F18%2FBSGS%20(Baby%20Steps%20Giant%20Steps)%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F%2F</url>
    <content type="text"><![CDATA[BSGS (Baby Steps Giant Steps)从入门到入土 BSGS (Baby Steps Giant Steps)从入门到入土1.BSGS求解如关于$x$的方程$A^x≡B \mod p$ 的最小整数解。$(A,p互质,p为质数)$ 不难发现$x&lt;=p$ 因为会出现循环。 靠虑将$x$分解为$i\times sqrt(x)-j$ 。 则原式化为$A^{i\times \lceil sqrt(x)\rceil}\times A^{-j}≡B \mod p$ 对$A^{-j}$求逆元得$A^{i\times \lceil sqrt(x)\rceil}≡B\times A^j \mod p$ 因为可以求一个同余方程$A^{-j}\times inv_{A^{-j}}≡1 mod p$ 显而易见$inv_{A^{-j}}$即为$A^j$ ,其实有点像移项，可惜$p$不与$A$互质移不过来，可能导致左边$mod p$后为$0$ 然后可知在$mod p$的意义下左右两式相等。 所以就可以用$map$吧左右的值映射成它的指数，先做右边($j$从$0$枚举到$\lceil sqrt(x)\rceil$),并把每次的$j$映射到$map$以$B\times A^j$为下标的空间中。然后做左边($i$从$1$枚举到$ \lceil sqrt(x)\rceil$)，每次查表搞一搞，第一次遇到相同的值就可以拿现在的$i\times \lceil sqrt(x)\rceil$与表中的$j$相减即为最小值，因为此时$i\times \lceil sqrt(x)\rceil$最小，$j$最大。 理论时间复杂度为$O(sqrt(p))$,但由于用了$map$所以多了红黑树查值的复杂度，所以多了个$log$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;long long b,p,a;void Read(long long &amp;x)&#123; long long f=1;x=0;char ch=getchar(); while (!isdigit(ch))&#123;if (ch=='-') f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+ch-'0';ch=getchar();&#125; x*=f;&#125;long long KSM(long long base,long long index,long long p)&#123; long long Res=1; while (index) &#123; if (index%2==1) Res*=base,Res%=p; base*=base; base%=p; index/=2; &#125; return Res%p;&#125;long long BSGS(long long a,long long b,long long p)&#123; map &lt;long long,long long&gt; m; long long X=(long long)ceil(sqrt(p)); m[b]=0; long long Ans_=b; for (int i=1;i&lt;=X;i++) Ans_*=a,Ans_%=p,m[Ans_]=i; long long Ans__=KSM(a,X,p); long long Ans___=1,Ans=-1; for (int i=1;i&lt;=X;i++) &#123; Ans___*=Ans__,Ans___%=p; if (m.count(Ans___)) &#123;Ans=i*X-m[Ans___];break;&#125; &#125; return Ans;&#125;int main() &#123; Read(p),Read(a),Read(b); long long answer=BSGS(a,b,p); if (answer==-1) cout&lt;&lt;"no solution"&lt;&lt;endl; else cout&lt;&lt;answer&lt;&lt;endl; return 0;&#125; 2.exBSGS若$A,p$不互质，那普通的$BSGS$就难以胜任了，所以需要使用$exBSGS$ 其实也很简单，假设$t=gcd(A,p)$,则可推出$A^{x-1}\times \frac{A}{t}≡\frac{B}{t} \mod p$ 若$t\nmid B$,则只有$B=1$时有$x=0$的最小解 若$t \mid b $,则当$t=1$时用$BSGS$,求解即可。 反复执行，直至$A,p$互质。 最后，若此过程需要反复进行$k$次,则答案为$BSGS$的解$x+k$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;long long b,p,a;void Read(long long &amp;x)&#123; long long f=1;x=0;char ch=getchar(); while (!isdigit(ch))&#123;if (ch=='-') f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=x*10+ch-'0';ch=getchar();&#125; x*=f;&#125;long long gcd(long long a,long long b)&#123; if (b==0) return a; return gcd(b,a%b);&#125;long long KSM(long long base,long long index,long long p)&#123; long long Res=1; while (index) &#123; if (index%2==1) Res*=base,Res%=p; base*=base; base%=p; index/=2; &#125; return Res%p;&#125;void ex_gcd(long long a,long long b,long long &amp;d,long long &amp;x,long long &amp;y) &#123; if (b==0) x=1,y=0,d=a; else &#123; ex_gcd(b,a%b,d,x,y); long long tmp=x;x=y;y=tmp-a/b*y; &#125;&#125;long long inv(long long a,long long b)&#123; long long x,y,d; ex_gcd(a,b,d,x,y); return (x%b+b)%b;&#125;long long BSGS(long long a,long long b,long long p)&#123; map &lt;long long,long long&gt; m; long long X=(long long)ceil(sqrt(p)); m[b]=0; long long Ans_=b; for (int i=1;i&lt;=X;i++) Ans_*=a,Ans_%=p,m[Ans_]=i; long long Ans__=KSM(a,X,p); long long Ans___=1,Ans=-1; for (int i=1;i&lt;=X;i++) &#123; Ans___*=Ans__,Ans___%=p; if (m.count(Ans___)) &#123;Ans=i*X-m[Ans___];break;&#125; &#125; return Ans;&#125;long long exBSGS(long long a,long long b,long long p)&#123; if (b==1||p==1)return 0; long long g=gcd(a,p),k=0,na=1; while (g!=1) &#123; if (b%g!=0)return -1; k++;b/=g;p/=g;na=na*(a/g)%p; if (na==b)return k; g=gcd(a,p); &#125; long long f=BSGS(a%p,b*inv(na,p)%p,p); if (f==-1)return -1; return f+k;&#125;int main() &#123; while (1) &#123; Read(a),Read(p),Read(b); if (p==0||a==0||b==0) break; long long answer=exBSGS(a,b,p); if (answer==-1) cout&lt;&lt;"No Solution"&lt;&lt;endl; else cout&lt;&lt;answer&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>-BSGS&amp;exBSGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟退火]]></title>
    <url>%2F2019%2F08%2F04%2F%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%2F</url>
    <content type="text"><![CDATA[模拟退火学习小结 关于模拟退火(以下来自百度百科) 模拟退火算法（Simulate Anneal，SA）是一种通用概率演算法，用来在一个大的搜寻空间内找寻命题的最优解。模拟退火是由S.Kirkpatrick, C.D.Gelatt和M.P.Vecchi在1983年所发明的。V.Čern&yacute;在1985年也独立发明此演算法。模拟退火算法是解决TSP问题的有效方法之一。 模拟退火的出发点是基于物理中固体物质的退火过程与一般组合优化问题之间的相似性。模拟退火算法是一种通用的优化算法，其物理退火过程由加温过程、等温过程、冷却过程这三部分组成。 所以要学OI先学好物理 模拟退火的具体流程先了解爬山算法吧！ 爬山算法就是对于一个函数随机选一个起始点，然后向着峰爬（最大or最小）。 但容易陷入局部最优解，如多峰函数。 而模拟退火则是用了一种较为科(玄)学的方法避免陷入局部最优解。 怎么做呢？ 就是对于一个较差的解，我们也有几率接受，假设此新解与最优解的差为$\Delta E$，此时温度为$T$,则概率为$e^{\frac{\Delta E}{kT}}$。($k$为一随机数，也可将$k$置为一常数)。 每次Rand这个$\Delta E$，一般为$(rand()\times 2-RANDMAX)\times Temperature$ $RANDMAX$为你这个种子的$Rand$最大值。这样方便$Rand$到正数和负数。 然后就判断是否接受后降温即可(一般取$0.9到0.99$之间,$Temperature*Down$) 当然，这是个玄学算法，需要有玄学的方法加强它的准确性。 以下推荐几种 分块退火(对每块退火后合并答案) 多退火几次 选多个起始位置 温度高点 降温系数慢点 种子选好点(比如某个八位质数$srand(time(0))$) 烧香祈福，提交前不要抽卡，洗把脸等等 例题平衡点/吊打XXX 均分数据 在此给出$平衡点/吊打XXX$的标程，$均分数据$由于最近没时间以后在更。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;#define Down 0.997#define MAXN 1005using namespace std;int N;double Ans_x=0,Ans_y=0,Ans_w;struct parm&#123;int x,y,w;&#125;Val[MAXN];struct node&#123; inline void Init(int &amp;x) &#123; int f=1;x=0;char ch=getchar(); while ('9'&lt;ch||ch&lt;'0') &#123;if (ch=='-') f=-1;ch=getchar();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-'0';ch=getchar();&#125; x*=f; &#125; inline void Outit(int x) &#123; if (x&lt;0) putchar('-'),x*=-1; if (x&gt;9) Outit(x/10); putchar(x%10+'0'); &#125;&#125;Put;struct Get_Ans&#123; double Get_Energy(double x,double y)//系统能量 &#123; double Sum=0; for (int i=1;i&lt;=N;i++) &#123; double dx=x-Val[i].x,dy=y-Val[i].y; Sum+=(double)sqrt(dx*dx+dy*dy)*Val[i].w; &#125; return Sum; &#125; void SA() &#123; double Tep=6000; while (Tep&gt;1e-15) &#123; double New_x=Ans_x+(rand()*2-RAND_MAX)*Tep; double New_y=Ans_y+(rand()*2-RAND_MAX)*Tep; double New_w=Get_Energy(New_x,New_y); double Delta=New_w-Ans_w; if (Delta&lt;0) Ans_x=New_x,Ans_y=New_y,Ans_w=New_w; else if (exp(-Delta/Tep)*RAND_MAX&gt;rand()) Ans_x=New_x,Ans_y=New_y; Tep*=Down; &#125; &#125;&#125;T;int main()&#123; srand(time(0));srand(rand());srand(rand());srand(rand());srand(rand());srand(rand());srand(rand()); Put.Init(N); for (int i=1;i&lt;=N;i++) Put.Init(Val[i].x),Put.Init(Val[i].y),Put.Init(Val[i].w),Ans_x+=Val[i].x,Ans_y+=Val[i].y; //for (int i=1;i&lt;=N;i++) cout&lt;&lt;Val[i].x&lt;&lt;" "&lt;&lt;Val[i].y&lt;&lt;" "&lt;&lt;Val[i].w&lt;&lt;endl; Ans_x=(double)Ans_x/N;Ans_y=(double)Ans_y/N; Ans_w=T.Get_Energy(Ans_x,Ans_y); T.SA(); T.SA(); T.SA(); T.SA(); T.SA(); printf("%.3lf %.3lf\n",Ans_x,Ans_y); return 0;&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>-模拟退火</tag>
      </tags>
  </entry>
</search>
